{"version":3,"sources":["components/AddCategory.js","components/GifGridItem.js","helpers/getGifs.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","categorias","setCategorias","useState","inputValue","setInputValue","input","mostrarAlerta","setMostrarAlerta","categoria","categoriaRepetida","setCategoriaRepetida","convertirMayusculas","e","charAt","toUpperCase","toLowerCase","slice","sinCambio","contieneTextoRepetido","indexOf","sinCambioTextoRepetido","alerta","fontSize","paddingTop","onSubmit","preventDefault","maxLength","type","placeholder","value","onChange","target","replace","onClick","style","backgroundColor","borderRadius","paddingBottom","marginLeft","color","length","GifGridItem","title","url","id","ultimaCategoria","className","src","alt","fontWeight","getGifs","cantidad","apiKey","a","encodeURI","fetch","resp","json","data","gifs","map","gif","images","downsized_medium","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","textAlign","marginBottom","reverse","image","lastItem","key","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f1e84c2f.chunk.js","sourcesContent":["import React, { useState } from 'react'\n\nexport const AddCategory = ({categorias, setCategorias}) =>{\n\n    // Hooks:\n    const [inputValue, setInputValue] = useState('')\n    const [mostrarAlerta, setMostrarAlerta] = useState({input:true})\n    const [categoriaRepetida, setCategoriaRepetida] = useState({categoria: true})\n\n    // Funciones\n    const convertirMayusculas = (e) => e.charAt(0) === ' ' ? e.charAt(1).toUpperCase() + e.toLowerCase().slice(1) : e.charAt(0).toUpperCase() + e.toLowerCase().slice(1)\n\n    const handleAgregar = () => {\n        setCategorias([convertirMayusculas(inputValue), ...categorias])\n    }\n\n    const sinCambio = inputValue !== '' && inputValue !== ' '\n    \n    // para saber si hay repetidas\n    const contieneTextoRepetido = categorias.indexOf(inputValue) === -1\n    // para sabir si hay repetido y aun no hay cambios ene l iput\n    const sinCambioTextoRepetido = sinCambio && contieneTextoRepetido\n\n    // input en ENTER se activa:\n    const handleSubmit = (e) => {\n        // esto lo que hace es evitar el funcionamiento por defecto del form:\n        e.preventDefault();\n\n        // utilizando el form al picar enter en el input se activa el submit y me evito este codigo:\n        // e => (e.keyCode === 13)\n    }\n\n    \n    const handleChange = (e) => {\n        // manejandoDobleEspacio\n        setInputValue(e.target.value.replace(/ +(?= )/g,''))\n    }\n    \n    const agregarCategoria = () => {\n        (sinCambioTextoRepetido) && handleAgregar(); \n        (sinCambioTextoRepetido) && setMostrarAlerta(false); \n        (sinCambio && !contieneTextoRepetido) && setCategoriaRepetida(false); \n        (sinCambio && contieneTextoRepetido) && setCategoriaRepetida(true)\n    }\n    \n    // styles\n    const boton = {backgroundColor: 'white', borderRadius: '10px', paddingBottom: '2px', marginLeft: '5px'}\n    const alerta = {fontSize: '12px', paddingTop: '3px',}\n    \n    return(\n        <>\n            <form onSubmit={handleSubmit}>\n                <input \n                    maxLength={20} \n                    type=\"text\" \n                    placeholder=\"Agregue un categoria\" \n                    value={convertirMayusculas(inputValue)} \n                    // ya no es necesario porque esta el form onEnter:\n                    // onKeyDown={e => (e.keyCode === 13) && agregarCategoria()} \n                    onChange={handleChange} \n                />\n                <button onClick={agregarCategoria}  style={{...boton}}>Agregar</button>\n            </form>\n\n           {(!mostrarAlerta && categoriaRepetida) && \n                <div style={{...alerta, color: 'green'}}>\n                    Categoria {categorias[categorias.length -1 ]} creada con exito!\n                </div>\n           }\n\n            {!(categoriaRepetida) && \n                <div style={{...alerta, color: 'red'}}>Categoria repetida.</div>\n            }\n        </>\n    )\n}\n\n\n\nexport default AddCategory;","import React from 'react'\n\nexport const GifGridItem = ({title, url, id, ultimaCategoria, categorias}) => {\n    return (\n        <div className={\"card\"}>\n             <img style={{}} src={url} alt={title}/>\n                    <p style={{fontWeight: 'bold'}}>{title}</p>\n        </div>\n    )\n}\n\n\nexport default GifGridItem","// la volvi async para que los cargu\nexport const getGifs = async(categorias, cantidad, apiKey) => {\n\n    // encodeURI lo que hace es que que reemplaza espacios con %20\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(categorias) }&limit=${cantidad}&api_key=${apiKey}`\n    // la respuesta tiene q cargar el url con await por el async\n    const resp = await fetch(url)\n    const {data} = await resp.json();\n\n    const gifs = data.map(gif => {\n        return {\n            id: gif.id,\n            title: gif.title,\n            // se pone un ? despues de images lo que hace que si no hay imagen que no se ejecute la sig parte del codigo -> muy util para probar en otros codigos\n            url: gif.images?.downsized_medium.url\n        }\n    })\n\n    return gifs;\n}\n\n","import React from 'react'\nimport GifGridItem from './GifGridItem'\n// import { getGifs } from '../helpers/getGifs'\nimport { useFetchGifs } from '../hooks/useFetchGifs'\n\nexport const GifGrid = ({categorias, cantidad, ultimaCategoria}) => {\n\n\n    // Cuando esto se ejecuta lo que hace es que hace que se vuelva a ejecutar el getGifs cada que haya un cambio, esto es porque hay un cambio en este nivel en el componente\n    // const [count, setCount] = useState(0);\n\n    // const [images, setImages] = useState([])\n\n    // commente esto porque voy a hacer un custom hook, los hooks siempre empiezan con useFuncionAlgo esta en carpeta de hooks\n    // useEffect(() => {\n    //     getGifs(categorias, cantidad, apiKey).then(img => setImages(img));\n\n    //     // el segundo argumento es un arreglo de dependencias, sirve para parar el que se ejecute mas el getGifs, esta parte es igual al componentDidMount()\n    // }, [categorias, cantidad])\n\n    // const state = useFetchGifs()\n    // lo imsmo pero desestructurado\n    // para darle un nombre especifico a la data se usan : data:images\n    const { data:images,loading } = useFetchGifs(categorias, cantidad)\n    \n\n    // si esto lo pongo aqui se ejecuta cuando carga\n    // getGifs()\n    // lo pase arriba a useEffect para que no se ejecute el codigo cada vez que haya un cambio en el componente\n    return (\n            <>\n                <div style={{textAlign: 'center', marginBottom: '4px', fontSize: '25px', fontWeight: 'bolder'}}>{categorias}</div>\n                {loading && <p className=\"animate__flash\">\n                    Cargando...\n                </p> }\n                    <div className=\"card-grid\">\n                        {/* <button onClick={() => setCount(count +1)}>Set count +1</button> */}\n                        {images.reverse().map(image =>\n                            <GifGridItem\n                            ultimaCategoria={ultimaCategoria}\n                            categorias={categorias}\n                            lastItem={[categorias[1]] && true}\n                            key={image.id}\n                            // esto es como yo lo hacia\n                            // images={image}\n                            // id={id} etc...\n                            // esto es como debe de ser:\n                            // mando un spread de la informacion de image como props, cada prop de las imagenes se manda como prop independiente\n                            {...image}\n                            />\n                        )}\n                    </div>\n            </>\n    )\n}\n","import { useState, useEffect } from \"react\"\nimport { getGifs } from \"../helpers/getGifs\"\n\nexport const useFetchGifs = ( categorias, cantidad ) => {\n    // el apikey lo quiero pedir aqui y no en GifGrid: entonces en props no lo mando pero si lo regreso en getGifs\n    const apiKey = '6ndyzTJHSlDiGxgJKJkO1spzFSyEFRD6'\n    const [state, setState] = useState({\n        data: [], \n        loading: true\n    })\n    // el useEffect: Es el equivalente funcional a componentDidMount, componentDidUpdate, y componentWillUnmount en los componentes de clase.\n    useEffect(() => {\n        getGifs( categorias, cantidad, apiKey )\n            .then( imgs => {\n                setState({\n                    data: imgs,\n                    loading: false\n                })\n            })\n        },[categorias, cantidad, apiKey])\n        \n    // asi podria activar despues de un timpo un cambio de estado\n    // setTimeout(() => {\n    //     setState({loading: false})\n    // }, 3000);\n\n    return state\n}\n","import React, { useState } from 'react'\n// import data from './data/data'\nimport AddCategory from './components/AddCategory'\nimport { GifGrid } from './components/GifGrid'\n\nexport const GifExpertApp = () =>{\n    // en vez de solo tener un arreglo primero y luego declarar el state={verduras,hierbas,frutas etc..} con lo sig: queda declarado el state y la info en un solo paso\n    const [categorias, setCategorias] = useState(['Morty Rick'])\n\n    const ultimaCategoria = categorias[0]\n\n    return(\n        <>\n            <h2>Agregar nueva categoria:</h2>\n            <hr/>\n            {/* obtengo con props los items para que se rendericen */}\n            <AddCategory categorias={categorias} setCategorias={ setCategorias } />\n            {/* <div style={{paddingTop: '10px'}}>\n            {/* en el map se reciben dos argumentos lo q se va a mapear y el indice, aunque es preferible en el key poner o el id o el elemento, sino puede dar errores raros\n            tambien puede dar error el categoria en este caso si es que hay algun duplicado\n                {categorias.map((categoria, i) => <li key={categoria}>{categoria}</li>)}\n            </div> \n            */}\n            <div style={{paddingTop: '10px'}}>\n            {/* el reverse lo puse para que la ultima busqueda salga antes */}\n                {categorias.map(categoria => (\n                    <GifGrid key={categoria} ultimaCategoria={ultimaCategoria} categorias={categoria} cantidad={10} />\n                ))}\n            </div> \n        </>\n    )\n}\n\n\n\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifApp from './GifExpertApp';\nimport './index.sass';\n\nReactDOM.render(\n<div>\n  <GifApp/>\n</div>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}